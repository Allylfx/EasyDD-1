function [f_dln] = analytic_traction(               ...
                                        se_node_coord , dln_node_coord,...
                                        burgers       , n_nodes       ,...
                                        n_nodes_t     , n_se, n_dln   ,...
                                        idxf, idxi, f_dln,...
                                        mu, nu, a, use_gpu, n_threads ,...
                                        para_scheme)
    %% Force calculation.
    % Allocating nodal and total force arrays
    nodal_force = zeros(3*n_se, n_nodes);
    total_force = zeros(3*n_se, 1);

    %% CUDA C calculation
    if use_gpu == 1
        % Provide a default number of threads in case none is given.
        if ~exists(n_threads)
            n_threads = 512;
        end %if
        % Provide a default parallelisaion scheme in case none is given.
        if ~exists(para_scheme)
            % Parallelise over dislocations.
            para_scheme = 1;
        end %if
        [nodal_force(:, 1), nodal_force(:, 2),...
         nodal_force(:, 3), nodal_force(:, 4),...
         total_force] = nodal_surface_force_linear_rectangle_mex_cuda(        ...
                                dln_node_coord(:, 1), dln_node_coord(:, 2)   ,...
                                se_node_coord (:, 1), se_node_coord (:, 2)   ,...
                                se_node_coord (:, 3), se_node_coord (:, 4)   ,...
                                burgers(:), mu, nu, a, n_se, n_dln, n_threads,...
                                para_scheme);
    % Serial force calculation in C.
    elseif use_gpu == 0
        [nodal_force(:, 1), nodal_force(:, 2),...
         nodal_force(:, 3), nodal_force(:, 4),...
         total_force] = nodal_surface_force_linear_rectangle_mex(          ...
                                dln_node_coord(:, 1), dln_node_coord(:, 2),...
                                se_node_coord (:, 1), se_node_coord (:, 2),...
                                se_node_coord (:, 3), se_node_coord (:, 4),...
                                burgers(:), mu, nu, a, n_se, n_dln);
    % Matlab version.
    else
        [nodal_force(:, 1), nodal_force(:, 2),...
         nodal_force(:, 3), nodal_force(:, 4),...
         total_force] = NodalSurfForceLinearRectangle2(                    ...
                                dln_node_coord(:, 1), dln_node_coord(:, 2),...
                                se_node_coord (:, 1), se_node_coord (:, 2),...
                                se_node_coord (:, 3), se_node_coord (:, 4),...
                                burgers(:), mu, nu, a, n_se, n_dln);
    end %if
    
    %% Map analytical nodal forces into a useful form for the force superposition scheme.
    % Loop through the number of nodes.
    k = 0;
    tmp = zeros(n_nodes, 1);
    for i = 1: n_nodes_t
        % Populate tmp array with the indices corresponding to nodes of 
        % the surface relevant surface element.
        tmp  = idxi(1 + k: k + n_nodes);
        % Obtain only the indices which are non-zero. Zero indices mean
        % those nodes are not under traction boundary conditions.
        tmp2 = tmp(idxi(1+k: k + n_nodes, 1) ~= 0);
        for j = 2:-1:0
            % The index is displaced by -2, -1, 0, corresponding to the
            % indices of the x, y, z coordinate respectively.
            % We add the force contributions from all surface elements a node
            % is part of. This gives us the total x,y,z forces on each node.
            f_dln(idxf(i) - j) = sum(nodal_force(tmp2 - j));
        end %for
        k = k + 4;
    end %for
    clear tmp; clear tmp2; clear k;
end % function